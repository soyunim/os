## 목차
1. [스와핑, 메모리 할당](#연속-메모리-할당)
2. [페이징](#가상-메모리)
3. [페이지 교체, 프레임 할당](#요구-페이징)

## 연속 메모리 할당
프로세스에 연속적인 메모리 공간을 할당하는 방식

> ### 스와핑
메모리에 적재된 프로세스들 중 현재 실행되지 않는 프로세스를 임시 보조기억장치 일부로 쫓아내고, 그렇게 생긴 메모리 상 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식

프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시에 실행할 수 있음

> ### 메모리 할당
#### 1. 최초 적합
프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식으로, 검색을 최소화 할 수 있고 결과적으로 빠른 할당 가능

#### 2. 최적 적합
운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식

#### 3. 최악 적합
운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식


> ### 외부 단편화
프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상


## 가상 메모리
실행하고자 하는 프로그램을 일부만 메모리에 적재해 실제 물리메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술

가상 메모리 관리 기법에는 크게 페이징, 세그멘테이션이 있음

> ### 페이징
대부분의 운영체제가 사용

프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자르고, 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법

> #### 페이징의 이점 - 쓰기 시 복사
유닉스와 리눅스 같은 운영체제에서 fork시스템 호출을 하면 부모 프로세스의 복사본이 자식 프로세스로서 생성된다.

새롭게 생성된 자식 프로세스의 코드 및 데이터 영역은 부모 프로세스가 적재된 메모리 공간과는 전혀 다른 메모리 공간에 생성된다.
부모 프로세스의 메모리 영역이 다른 영역에 자식 프로세스로서 복제되고, 각 프로세스의 페이지 테이블은 자신의 고유한 페이지가 할당된 프레임을 가리킨다.

그러나 이 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기한다.

반면, 쓰기 시 복사는 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다.
이로써 굳이 부모 프로세스의 메모리 공간을 복사하지 않아도 동일한 코드 및 데이터 영역을 가질 수 있다.

프로세스 간에는 자원을 공유하지 않기 때문에 부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제되는데, 이를 쓰기 시 복사라고 한다.

쓰기 시 복사를 통해 프로세스 생성 시간을 줄이는 것은 물론 메모리 공간 절약도 가능하다.

> ### 페이지 테이블
페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표로, CPU가 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 함

> ### 페이지 테이블 엔트리
페이지 테이블의 각 행을 말함

페이지 테이블 엔트리에 담기는 정보로는 페이지 번호, 프레임 번호, 유효 비트, 보호 비트, 참조 비트, 수정 비트가 있음

#### 1. 유효비트
현재 해당 페이지에 접근 가능한지 여부를 알려줌

페이지가 메모리에 적재되어 있다면 유효비트가 1, 페이지가 메모리에 적재되어있지 않다면 유효 비트는 0이 됨

만일 CPU가 유효 비트 0인 페이지로 접근하려고 하면 페이지 폴트라는 예외가 발생함.

#### 2. 보호비트
페이지 보호 기능을 위해 존재하는 비트

보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지 인지 나타낼 수 있다.

비트가 0이면 읽기만 가능한 페이지임을 나타내고, 1이면 읽고 쓰기가 모두 가능한 페이지임을 나타낸다.

가령 보호 비트가 세 개라면, rwx(읽기, 쓰기, 실행) 순으로 해석하면 된다. 

EX) 100이라면 읽기만 가능, 110이라면 읽고 쓰기가 가능, 101이라면 읽기와 실행만 가능

#### 3. 참조비트
CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다.

적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지는 0으로 유지된다.

#### 4. 수정비트
해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다. 더티비트라고도 부른다.

비트가 1이면 변경된 적이 있는 페이지, 0이면 변경된 적이 없는 페이지임을 나타낸다.

수정비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지 판단하기 위해 존재한다.


> ### 페이지 폴트
CPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사하다.
1. CPU는 기존 작업 내역을 백업한다.
2. 페이지 폴트 처리 루틴을 실행한다.
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해준다.
4. 페이지 폴트를 처리했다면 CPU는 해당 페이지에 접근할 수 있게 된다.

> ### 페이지 테이블 베이스 레지스터 (PTBR)
CPU내에 있으며 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴

예를 들어 프로세스 A가 실행될 때 PTBR은 프로세스 A의 페이지 테이블을 가리키고, CPU는 프로세스 A의 페이지 테이블을 통해 프로세스 A의 페이지가 적재된 프레임을 알 수 있다.

그러나 이렇게 페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다는 문제가 있다. 메모리에 있는 페이지 테이블을 보기 위해 한 번, 그렇게 알게 된 프레임에 접근 하기 위해 한 번, 총 두 번의 메모리 접근이 필요하다.

> ### TLB
위와 같은 메모리 접근 시간이 두 배로 늘어나는 문제를 해결하기 위해 CPU곁에 TLB라는 페이지 테이블의 캐시 메모리를 둔다.

페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 ㅁ내용을 저장한다.

CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB히트라고 한다. 만약에 없을 경우 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 저 ㅂ근 하는 수밖에 없다. 이를 TLB미스라고 한다.

> ### 계층적 페이징
프로세스의 크기가 커지면 자연히 프로세스 테이블의 크기도 커지기 때문에 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비이다. 

프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법이 바로 계층적 페이징이다.

페이지 테이블을 여러 개의 페이지로 쪼갠 후(안쪽 테이블), 쪼갠 페이지들을 가리키는 페이지 테이블(바깥 테이블)을 두는 방식이 계층적 페이징이다.

페이지를 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없어 막대한 크기의 페이지 테이블로 인해 낭비되는 공간을 줄일 수 있다.

계층적 페이지를 사용하지 않을 경우 논리 주소는 {변위, 페이지번호}로 이루어진다. 그러나 계층적 페이징을 이용하는 환경에서의 논리 주소는 {바깥 페이지 번호, 안쪽 페이지 번호, 변위}로 이루어진다.

## 요구 페이징
처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법.

실행에 요구되는 페이지만 적재한다.

요구 페이징의 기본적인 양상은 다음과 같다.  
1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다.
3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0일 경우) 페이지 폴트가 발생한다.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
5. 1번을 다시 실행한다.

아무런 페이지도 메모리에 적재하지 않은 채 실행하는 것을 순수 요구 페이징 기법이라고 한다. 이 경우 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하게 된다.

요구 페이징 시스템이 안정적으로 작동하려면 페이지 교체와 프레임 할당을 해결해야 한다.

> ### 페이지 교체
당장 실행에 필요한 페이지 적재를 위해 메모리에 적재된 페이지를 보조 기억 장치로 보내야 하는데, 어떤 걸 보낼지 정하는 것을 '페이지 교체 알고리즘'이라 한다.

페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘이라 하는데, 이를 알기 위해선 페이지 폴트 횟수를 알아야 한다.

페이지 폴트 횟수는 페이지 참조열을 통해 알 수 있다.

> ### 페이지 참조열
CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열

연속된 페이지를 생략하는 이유는 중복된 페이지 참조 행위는 페이지 폴트를 발생시키지 않기 때문이다.

> ### 페이지 교체 알고리즘
- FIFO 페이지 교체 알고리즘  
: 가장 먼저 메모리에 올라온 페이지부터 쫓아내는 방식  
: 실행 초기에 적재된 페이지 속에는 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있기에 좋은 알고리즘은 아님.

- 2차 기회 페이지 교체 알고리즘  
: FIFO페이지 교체 알고리즘의 부작용을 어느 정도 개선한 알고리즘  
: FIFO알고리즘처럼 가장 오래 머물렀던 페이지를 대상으로 내보낼 페이지를 선별하지만, 만일 페이지의 참조 비트가 1일 경우 당장 내쫓지 않고 참조비트를 0으로 만든 뒤 현재 시간을 적재 시간으로 설정해준다. 기회를 한 번 더 주는 셈이다.

- 최적 페이지 교체 알고리즘  
: CPU에 의해 참조되는 횟수는 고려하지 않는 페이지 교체 알고리즘  
: 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘  
: 페이지 교체 알고리즘 중 페이지 폴트 발생 빈도가 가장 낮다. 그러나 프로세스가 앞으로 메모리 어느 부분을 어떻게 참조할지 미리 알 수가 없기에 실제 구현이 어렵다.

- LRU 페이지 교체 알고리즘  
: Least Recently Used  
: 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘  
: 최적 페이지 교체 알고리즘을 비슷하게 구현해 낸 알고리즘

> ### 스래싱
프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생한다.

이처럼 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요해 성능이 저하되는 문제, 지나치게 빈번한 페이지 교체로 인해 CPU이용률이 낮아지는 문제를 스래싱(Thrashing)이라 한다.

스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다. 그렇기에 운영체제는 각 프로세스들이 무리없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해줄 수 있어야 한다.

> ### 프레임 할당
- 균등할당  
: 모든 프로세스에 동일한 프레임을 분배하는 방식  
: 실행되는 프로세스의 크기가 다르므로 동일한 프레임 개수를 할당하는 것은 비합리적

- 비례할당  
: 프로세스 크기에 따라 프레임을 배분하는 방식  
: 프로세스의 크기가 클지라도 막상 실행해보면 많은 프레임을 필요로 하지 않는 경우와 그 반대의 경우가 있으므로 이 또한 완벽한 방식이 아님

- 작업 집합 모델 기반 할당  
: 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억해 빈번한 페이지 교체를 방지함  
: 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 '작업 집합'이라 하는데, 이 작업 집합의 크기만큼 프레임을 할당하는 방식
 
- 페이지 폴트 빈도 기반 할당  
: 페이지 폴트율의 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식
